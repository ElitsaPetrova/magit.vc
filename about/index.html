<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>Magit! A Git Porcelain inside Emacs</title>
    <meta name="author"      content="Jonas Bernoulli <jonas@bernoul.li>">
    <meta name="description" content="Magit is an Emacs interace to it Git">
    <meta name="keywords"    content="emacs, git, version control">
    <link rel="icon" href="/img/M.ico" type="image/x-icon">
    <link rel="stylesheet" type="text/css" href="/css/page.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic,700italic">
    <script type="text/javascript" src="quotes.js"></script>
  </head>

  <body>
    <header>
      <a href="/"><img id="M" src="/img/m.png"></a>
      <h1>Magit!</h1>
      <h2>A Git Porcelain inside Emacs</h2>
    </header>

    <section>
      <p>
        Magit is an interface to the version control system
        <a href="https://git-scm.com">Git</a>, implemented as an
        <a href="https://www.gnu.org/software/emacs">Emacs</a> package.
        Magit aspires to be a complete Git porcelain.  While we cannot
        (yet) claim that Magit wraps and improves upon each and every
        Git command, it is complete enough to allow even experienced
        Git users to perform almost all of their daily version control
        tasks directly from within Emacs.  While many fine Git clients
        exist, only Magit and Git itself deserve to be called
        porcelains. <a class="small" href="/">(less)</a>
      </p>
      <p>
        Staging and otherwise applying changes is one of the most
        important features in a Git porcelain and here Magit outshines
        anything else, including Git itself.  Git's own staging interface
        (<code>git add --patch</code>) is so cumbersome that many
        users only use it in exceptional cases.  In Magit staging a
        hunk or even just part of a hunk is as trivial as staging all
        changes made to a file.
      </p>
      <p>
        The most visible part of Magit's interface is the status
        buffer, which displays information about the current
        repository.  Its content is created by running several Git
        commands and making their output actionable.  Among other
        things, it displays information about the current branch,
        lists unpulled and unpushed changes and contains sections
        displaying the staged and unstaged changes.  That might sound
        noisy, but, since sections are collapsible, it's not.
      </p>
      <p>
        To stage or unstage a change one places the cursor on the
        change and then types <code>s</code> or <code>u</code>.  The
        change can be a file or a hunk, or when the region is active
        (i.e. when there is a selection) several files or hunks, or
        even just part of a hunk.  The change or changes that these
        commands - and many others - would act on are highlighted.
      </p>
      <p>
        Magit also implements several other "apply variants" in
        addition to staging and unstaging.  One can discard or reverse
        a change, or apply it to the working tree.  Git's own
        porcelain only supports this for staging and unstaging and you
        would have to do something like <code>git diff ... | ??? | git
        apply ...</code> to discard, revert, or apply a single hunk on
        the command line.  In fact that's exactly what Magit does
        internally (which is what lead to the term "apply variants").
      </p>
      <p>
        Magit isn't just for Git experts, but it does assume some
        prior experience with Git as well as Emacs.  That being said,
        many users have reported that using Magit was what finally
        taught them what Git it is capable off and how to use it to
        its fullest.  Other users wished they had switched to Emacs
        sooner so that they would have gotten their hands on Magit
        earlier.
      </p>
      <p>
        While one has to know the basic features of Emacs to be able to make
        full use of Magit, acquiring just enough Emacs skills doesn't take
        long and is worth it, even for users who prefer other editors.  Vim
        users are advised to give
        <a href="https://bitbucket.org/lyro/evil/wiki/Home">Evil</a>,
        the "Extensible VI Layer for Emacs", and
        <a href="https://github.com/syl20bnr/spacemacs">Spacemacs</a>,
        an "Emacs starter-kit focused on Evil" a try.
      </p>
      <p>
        Magit provides a consistent and efficient Git porcelain.
        After a short learning period, you will be able to perform
        most of your daily version control tasks faster than you would
        on the command line.  You will likely also start using
        features that seemed too daunting in the past.
      </p>
      <p>
        Magit fully embraces Git.  It exposes many advanced features
        using a simple but flexible interface instead of only wrapping
        the trivial ones like many GUI clients do.  Of course Magit
        supports logging, cloning, pushing, and other commands that
        usually don't fail in spectacular ways; but it also supports
        tasks that often cannot be completed in a single step.  Magit
        fully supports tasks such as merging, rebasing,
        cherry-picking, reverting, and blaming by not only providing a
        command to initiate these tasks but also by displaying context
        sensitive information along the way and providing commands
        that are useful for resolving conflicts and resuming the
        sequence after doing so.
      </p>
      <p>
        Magit wraps and in many cases improves upon at least the following
        Git porcelain commands: add, am, bisect, blame, branch, checkout,
        cherry, cherry-pick, clean, clone, commit, config, describe, diff,
        fetch, format-patch, init, log, merge, merge-tree, mv, notes,
        pull, rebase, reflog, remote, request-pull, reset, revert, rm,
        show, stash, submodule, and tag.  Many more Magit porcelain
        commands are implemented on top of Git plumbing commands.
      </p>
    </section>
  </body>
</html>
